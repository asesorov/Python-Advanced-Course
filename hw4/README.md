# Homework 4

Потоки и процессы

## Task 4.1
Взять функцию подсчета чисел Фибоначчи и сравнить время исполнения кода (вызова функции от большого числа n (чтобы была видна разница в запусках на потоках и процессах) 10 раз через 10 потоков\процессов) при использовании threading и multiprocessing

Необходимо сравнить время выполнения при синхронном запуске, использовании потоков и процессов. 

Артефакт - текстовый файл с результатами запуска различными методами.

Код: [здесь](task_1/benchmark.py)

Артефакты: [здесь](artifacts/4.1/)

## Task 4.2
Переписать функцию integrate для того, чтобы ее выполнение можно было распараллелить. Использовать concurrent.futures: ThreadPoolExecutor и ProcessPoolExecutor.  Добавить логирование (когда какая задача запускается), сравнить время выполнения для integrate(math.cos, 0, math.pi / 2, n_jobs=n_jobs) при разном числе n_jobs (от 1 до cpu_num*2) при использовании ThreadPoolExecutor и ProcessPoolExecutor. 

Артефакт - файл логов, файл сравнения времени исполнения в обоих случаях в зависимости от числа воркеров


Код: [здесь](task_2/integrate_benchmark.py)

Артефакты: [здесь](artifacts/4.2/)

## Task 4.3
Практика работы с процессами. Использование multiprocessing.Queue
 и multiprocessing.Pipe. Реализовать следующую схему приложения:
У вас есть главный процесс и 2 дочерних (A и B). Из главного процесса вы можете через stdin отправлять сообщения (строки) в процесс A, которые будут складироваться в очередь. К каждому из сообщений процесс A будет применять .lower() и отправлять в процесс B (одно сообщение раз в 5 секунд). Процесс B должен отправлять закодированную строку через rot13 и отправлять в главный процесс откуда печатать в stdout.

Артефакт - текстовый файл взаимодействия вас и программы (необходимо выводить время сообщений)


Код: [здесь](task_3/processes_mix.py)

Артефакты: [здесь](artifacts/4.3/)
